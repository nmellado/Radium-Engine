<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Radium Engine: Material management in the Radium Engine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Radium Engine
   &#160;<span id="projectnumber">8d7f844e79c210aea0caac3e6bb0e8e976cffd4d</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__home_travis_build_STORM-IRIT_Radium-Engine_Docs_material.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Material management in the Radium Engine </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A Material is a way to control the appearance of an object when rendering. It could be the definition of a classical rendering materials, a <em>Bidirectional Scattering Distribution function (BSDF)</em>, or just define the way a geometry could be rendered and how is computed the final color of an object.</p>
<p>A material is associated to the render geometry of an object (a Component in the Radium nomenclature) through a so called <em>Render Technique</em>. This association is managed by the <code>RenderObject</code> class.</p>
<p>This documentation aims at describing the way materials are managed in the Radium engine and how one can extend the set of available material, or specialized a renderer with ad-hoc (pseudo)-material.</p>
<h2>Material subsystem and Material Library</h2>
<p>The Radium Engine defines an abstract interface for material definition that allows easy extensibility of the Engine. This section describe the workflow of Material management from asset loading to rendering. Note that, for a given application or renderer, a Material could be defined directly without loading it from a file.</p>
<h3>The MaterialData interface</h3>
<p>The interface <code>MaterialData</code> define the external representation of a material. Even if this interface could be instantiated, it defines an abstract material that is not valid for the Engine. This interface must then be implemented to define materials that could be loaded from a file.</p>
<p>When defining a loadable material, the corresponding implementation must set the type of the material to a unique identifier that will be used after that to automatically generate different instances of the material. The implementation of the interface <code>MaterialData</code> can add whatever functions needed to construct and interact with the external representation of a material. These functions might then be used by the file loader able to understand this material and by the material converter, described below, that will be used by some systems to convert this external material definition to the Engine internal representation.</p>
<h3>The Material interface</h3>
<p>The <code>Material</code> interface defines the internal abstract representation of a Material. This interface will be used by the Engine, mainly by the <em>Render Technique</em> and the <em>Renderer</em>.</p>
<p>This interface defines all the methods needed to parametrized the OpenGL pipeline for rendering. When implementing this interface, it is a good idea to add two static methods to the implementation to allow to register and unregister the material into the Engine. These method could have the following profiles : </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMaterial : <span class="keyword">public</span> <a class="code" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// implementation of the abstract interface</span></div><div class="line">    ...</div><div class="line">private:</div><div class="line">    <span class="comment">// data member for MyMaterial</span></div><div class="line">    ...</div><div class="line">public:</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> registerMaterial();</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> unregisterMaterial();</div><div class="line">    <span class="comment">// MyMaterial specific public interface</span></div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><h3>Material converters</h3>
<p>This is used by the loading system to translate the external representation of a material to the internal one and associate this internal representation to a <code>RenderTechnique</code> inside a <code>RenderObject</code>component.</p>
<p>A material converter is a couple <code>&lt;std::string, std::function&lt;<a class="el" href="classRa_1_1Engine_1_1Material.html" title="Base class for materials/ Do not assume a given Material representation but only make the difference ...">Ra::Engine::Material</a>*(Ra::Asset::MaterialData*)&gt;&gt;</code> where the string gives the type of the material and the function is whatever is compatible with std::function :</p><ul>
<li>a lambda</li>
<li>a functor</li>
<li>a function with bind parameters ...</li>
</ul>
<p>The function is in charge of converting a concrete <code>Ra::Asset::MaterialData *</code> to a concrete <code><a class="el" href="classRa_1_1Engine_1_1Material.html" title="Base class for materials/ Do not assume a given Material representation but only make the difference ...">Ra::Engine::Material</a> *</code> according to the type of material described by the string ...</p>
<p>Material converters are managed by the engine through a Factory defined in the <code>namespace <a class="el" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html" title="A material converter is a couple &lt;std::string, std::function&lt;Ra::Engine::Material*(Ra::Core::Asset::M...">Ra::Engine::EngineMaterialConverters</a></code> and located in the <code>Engine/Renderer/Material</code> directory as below : </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>EngineMaterialConverters {</div><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#ab2495c753fa13f24d62be03e08a83d09">AssetMaterialPtr</a> = <span class="keyword">const</span> Ra::Asset::MaterialData*;</div><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#a7366420d17c1de81abf6bf5d4b5b8f08">RadiumMaterialPtr</a> = <a class="code" href="classRa_1_1Engine_1_1Material.html">Ra::Engine::Material</a>*;</div><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#af97fe019a3c335e8ee248209b0b1ee71">ConverterFunction</a> = std::function&lt; RadiumMaterialPtr( AssetMaterialPtr ) &gt;;</div><div class="line"></div><div class="line"><a class="code" href="RaEngine_8hpp.html#aa6975e66ca4c57b82c5c76aaceeec571">RA_ENGINE_API</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#ac79f2e35d9ad3d13a9aa484bdfcf68fa">registerMaterialConverter</a>( <span class="keyword">const</span> std::string&amp; name,</div><div class="line">                                              <a class="code" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#af97fe019a3c335e8ee248209b0b1ee71">ConverterFunction</a> converter );</div><div class="line"></div><div class="line"><a class="code" href="RaEngine_8hpp.html#aa6975e66ca4c57b82c5c76aaceeec571">RA_ENGINE_API</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#ac41449ebd949e8a7b1d93ff2a42acf92">removeMaterialConverter</a>( <span class="keyword">const</span> std::string&amp; name );</div><div class="line"></div><div class="line"><a class="code" href="RaEngine_8hpp.html#aa6975e66ca4c57b82c5c76aaceeec571">RA_ENGINE_API</a> std::pair&lt;bool, ConverterFunction&gt; <a class="code" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#ad440019d5fdaa657b3a483a705dc3657">getMaterialConverter</a>( <span class="keyword">const</span> std::string&amp; name );</div><div class="line"></div><div class="line">} <span class="comment">// namespace EngineMaterialConverters</span></div></div><!-- fragment --><h3>Render technique and materials</h3>
<p>A <code>RenderTechnique</code> correspond to the description of how to use Materials to render an object in openGL. Even if <code>RenderTechnique</code> is tightly coupled with the default <code>ForwardRenderer</code> of the engine, it could be used also with others renderer. Note nevertheless that RenderTechnique is not mandatory when defining a specific renderer as the association between the material and the geometry of a render object could be done explicitly.</p>
<p>To manage the way a Material could be used for rendering, a <code>RenderTechnique</code> is then a set of <em>shader configurations</em> associated to the different way a renderer will compute the final image. Based on the <code>ForwardRenderer</code> implementation in Radium, the set of configurations, with one configuration per rendering <em>passes</em> corresponds to the following :</p><ol type="1">
<li>Z-prepass : depth and ambient/environment lighting :<ul>
<li>Identified by the <code><a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html#af803212454983777ba8caaa24163e51dae13b847fdf01551fa704a192597e376c">Ra::Engine::RenderTechnique::Z_PREPASS</a></code> constant.</li>
<li>Required for the depth pre-pass of several renderer.</li>
<li>Must initialise the color buffer with the computation of ambient/environment lighting.</li>
<li>Must discard all non fully opaque fragments.</li>
<li>Default/Reference : `<code>Material/BlinnPhong/DepthAmbientBlinnPhong</code> shader</li>
</ul>
</li>
<li>Opaque lighting **(MANDATORY for default ForwardRenderer)**:<ul>
<li>Identified by the <code><a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html#af803212454983777ba8caaa24163e51da9c843288b3e60ed141014569ae035c0e">Ra::Engine::RenderTechnique::LIGHTING_OPAQUE</a></code> constant.</li>
<li>Main configuration, computes the resulting color according to a lighting configuration.</li>
<li>The lighting configuration might contains one or several sources of different types.</li>
<li>Must discard all non fully opaque fragments.</li>
<li>Default/Reference : BlinnPhong shader</li>
</ul>
</li>
<li>Transparent lighting :<ul>
<li>Identified by the <code><a class="el" href="classRa_1_1Engine_1_1RenderTechnique.html#af803212454983777ba8caaa24163e51da8cb69950239b9f21365388db545a64fd">Ra::Engine::RenderTechnique::LIGHTING_TRANSPARENT</a></code> constant.</li>
<li>Must discard fully transparent and fully opaque fragments, Others will be lit and blended according to the algorithm described in<ul>
<li>Weighted Blended Order-Independent Transparency Morgan McGuire, Louis Bavoil - NVIDIA Journal of Computer Graphics Techniques (JCGT), vol. 2, no. 2, 122-141, 2013 <a href="http://jcgt.org/published/0002/02/09/">http://jcgt.org/published/0002/02/09/</a></li>
</ul>
</li>
<li>Lighting is computed the same way as for Opaque Lighting</li>
<li>Default/Reference : <code>Material/BlinnPhong/LitOITBlinnPhong</code> shader</li>
<li>The transparent color weighting function might be the same as : ``` float weight(float z, float alpha) { <pre class="fragment"> // pow(alpha, colorResistance) : increase colorResistance if foreground transparent are affecting background 
 //                               transparent color
 // clamp(adjust / f(z), min, max) :
 //     adjust : Range adjustment to avoid saturating at the clamp bounds
 //     clamp bounds : to be tuned to avoid over or underflow of the reveleage texture.
 // f(z) = 1e-5 + pow(z/depthRange, orederingStrength)
 //     defRange : Depth range over which significant ordering discrimination is required. 
 //             Here, 10 image space units.
 //         Decrease if high-opacity surfaces seem “too transparent”,
 //         increase if distant transparents are blending together too much.
 //     orderingStrength : Ordering strength. Increase if background is showing through foreground too much.
 // 1e-5 + ... : avoid dividing by zero !

 return pow(alpha, 0.5) * clamp(10 / ( 1e-5 + pow(z/10, 6)  ), 1e-2, 3*1e3);
</pre> } ```</li>
</ul>
</li>
</ol>
<p><b>Note</b> that a specific renderer might use the same set of configurations but with a different semantic. One can imagine, for instance, that a renderer will only use the <em>Depth and ambient/environment</em> configuration in order to render an object without light source but with a specific color computation.</p>
<p>RenderTechniques are associated with Materials through a Builder Factory defined in the <code>namespace <a class="el" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html">Ra::Engine::EngineRenderTechniques</a></code> and located in the <code>Engine/Renderer/RenderTechnique</code> directory. This factory will manage default technique builders for each registered materials in the engine. A default technique builder will associate a set of predefined shader for each rendering pass to a Material type.</p>
<p>This association is based on the type, not on the instance. So it can vary from one instance to the other but requires then a manual construction of the render technique instead of an automatic one through the factory.</p>
<p>The <code>RenderTechnique</code> factory is defined as below : </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>EngineRenderTechniques {</div><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#a2ed5adf993934cc04f0c1ffbfea4b9f7">DefaultTechniqueBuilder</a> = std::function&lt;void( RenderTechnique&amp;, bool )&gt;;</div><div class="line"></div><div class="line"><a class="code" href="RaEngine_8hpp.html#aa6975e66ca4c57b82c5c76aaceeec571">RA_ENGINE_API</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#affc37bf84d5ff81342b5c09587eedc34">registerDefaultTechnique</a>( <span class="keyword">const</span> std::string&amp; name, <a class="code" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#a2ed5adf993934cc04f0c1ffbfea4b9f7">DefaultTechniqueBuilder</a> builder );</div><div class="line"></div><div class="line"><a class="code" href="RaEngine_8hpp.html#aa6975e66ca4c57b82c5c76aaceeec571">RA_ENGINE_API</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#a6e2ce86d7ae1f3822819477bf5bd7c74">removeDefaultTechnique</a>( <span class="keyword">const</span> std::string&amp; name );</div><div class="line"></div><div class="line"><a class="code" href="RaEngine_8hpp.html#aa6975e66ca4c57b82c5c76aaceeec571">RA_ENGINE_API</a> std::pair&lt;bool, DefaultTechniqueBuilder&gt; <a class="code" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#a5e831d5088144082e9bd3828323aa57a">getDefaultTechnique</a>( <span class="keyword">const</span> std::string&amp; name );</div><div class="line"></div><div class="line">} <span class="comment">// namespace EngineRenderTechniques</span></div></div><!-- fragment --><p><b>Note</b> that, if needed, an application could bypass the builder factory and construct directly a render technique. More, as the material is associated to the RenderObject component and not to the Render technique, an application with its own specific renderer could not use at all this functionality.</p>
<h2>Engine material management workflow</h2>
<p>For now (master v1), the engine manage only one default material corresponding the the Blinn-Phong BSDF. The type of this material is <code>"BlinnPhong"</code>. The workflow allowing the Engine to manage this material is the following.</p>
<h3>Making BlinnPhong a loadable material (see <em>The MaterialData interface</em>)</h3>
<p>This part of the Material management workflow is related to File loader. So, The corresponding classes are located in the <code>Core/File</code> subdirectory. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;src</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;└───Core</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;│   └───File</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;│       │   ...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;│       │   BlinnPhongMaterialData.cpp</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;│       │   BlinnPhongMaterialData.hpp</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;│       │   BlinnPhongMaterialData.inl</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;│       │   ...</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;│</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;...</div></div><!-- fragment --><p> The <code>BlinnPhongMaterialData</code> class is defined as : </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceRa.html">Ra</a> {</div><div class="line"><span class="keyword">namespace </span>Asset {</div><div class="line"></div><div class="line"><span class="keyword">class </span><a class="code" href="RaCore_8hpp.html#aa9257f423326d94574be80ac5b92a2e5">RA_CORE_API</a> BlinnPhongMaterialData : <span class="keyword">public</span> MaterialData {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> BlinnPhongMaterialData( <span class="keyword">const</span> std::string&amp; name = <span class="stringliteral">&quot;&quot;</span> );</div><div class="line">    ...</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">// namespace Asset</span></div><div class="line">} <span class="comment">// namespace Ra</span></div></div><!-- fragment --><p>Then, the Assimp loader, located in the <code>IO/AssimpLoader</code> subdirectory will instantiate the <code>BlinnPhongMaterialData</code> when loading a file in the following way : </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> AssimpGeometryDataLoader::loadMaterial( <span class="keyword">const</span> aiMaterial&amp; material,</div><div class="line">                                             Asset::GeometryData&amp; data )<span class="keyword"> const </span>{</div><div class="line">    <span class="comment">// Get the name of the material</span></div><div class="line">    std::string matName;</div><div class="line">    aiString assimpName;</div><div class="line">    <span class="keywordflow">if</span> ( AI_SUCCESS == material.Get( AI_MATKEY_NAME, assimpName ) )</div><div class="line">    {</div><div class="line">        matName = assimpName.C_Str();</div><div class="line">    }</div><div class="line">    <span class="comment">// Instanciate a BlinnPhongMaterialData object</span></div><div class="line">    <span class="keyword">auto</span> blinnPhongMaterial = <span class="keyword">new</span> Asset::BlinnPhongMaterialData( matName );</div><div class="line">    <span class="comment">// Fill the BlinnPhongMaterialData structure</span></div><div class="line">    ...</div><div class="line">    <span class="comment">// Associate the Material with the geometry</span></div><div class="line">    data.setMaterial( blinnPhongMaterial );</div><div class="line">}</div></div><!-- fragment --><h3>Making BlinnPhong a usable material (see <em>The Material interface</em>)</h3>
<p>This part of the Material management workflow is related to the Renderer part of the Engine. So, The corresponding classes are located in the <code>Engine/Renderer/Material</code> subdirectory. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;src</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;└───Engine</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;│   └───Renderer</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;│   │   └───Material</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;│   │   │   ...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;│   │   │   BlinnPhongMaterial.cpp</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;│   │   │   BlinnPhongMaterial.hpp</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;│   │   │   BlinnPhongMaterial.inl</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;│   │   │   ...</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;│   │   ...</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;│   ...</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;...</div></div><!-- fragment --><p> The <code>BlinnPhongMaterial</code> class is defined as : </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceRa.html">Ra</a> {</div><div class="line"><span class="keyword">namespace </span>Engine {</div><div class="line"></div><div class="line"><span class="keyword">class </span><a class="code" href="RaEngine_8hpp.html#aa6975e66ca4c57b82c5c76aaceeec571">RA_ENGINE_API</a> BlinnPhongMaterial final : <span class="keyword">public</span> Material {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RA_CORE_ALIGNED_NEW</div><div class="line">    <span class="keyword">explicit</span> BlinnPhongMaterial( <span class="keyword">const</span> std::string&amp; name );</div><div class="line">    ...</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    ...</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> registerMaterial();</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> unregisterMaterial();</div><div class="line">    ...</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">// namespace Engine</span></div><div class="line">} <span class="comment">// namespace Ra</span></div></div><!-- fragment --><h3>Registering the BlinnPhongMaterial to the Engine</h3>
<p>The registration (and unregistering) of a Material into the Engine consists in registering the material converter into the MaterialConvertersFactory and the RenderTechniqueBuilder into the RenderTechniqueFactory.</p>
<p>It is recommended (see above) to implement specific class methods in the Material implementations that will register and unregister the material type into the engine.</p>
<p>For the default <code>BlinnPhongMaterial</code>, which is of type <code>"BlinnPhong"</code>, these methods will do the following :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> BlinnPhongMaterial::registerMaterial() {</div><div class="line">    <span class="comment">// 1- register the Material converter for loading</span></div><div class="line">    <a class="code" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#ac79f2e35d9ad3d13a9aa484bdfcf68fa">EngineMaterialConverters::registerMaterialConverter</a>(</div><div class="line">        <span class="stringliteral">&quot;BlinnPhong&quot;</span>,</div><div class="line">        BlinnPhongMaterialConverter() );</div><div class="line"></div><div class="line">    <span class="comment">// 2- register the technique builder for rendering</span></div><div class="line">    <a class="code" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#affc37bf84d5ff81342b5c09587eedc34">Ra::Engine::EngineRenderTechniques::registerDefaultTechnique</a>(</div><div class="line">        <span class="stringliteral">&quot;BlinnPhong&quot;</span>,</div><div class="line">        []( <a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a>&amp; rt, <span class="keywordtype">bool</span> isTransparent ) {</div><div class="line">            <span class="comment">// Configuration for RenderTechnique::LIGHTING_OPAQUE (Mandatory)</span></div><div class="line">            <a class="code" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> lpconfig(</div><div class="line">                <span class="stringliteral">&quot;BlinnPhong&quot;</span>, <span class="stringliteral">&quot;Shaders/Materials/BlinnPhong/BlinnPhong.vert.glsl&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;Shaders/Materials/BlinnPhong/BlinnPhong.frag.glsl&quot;</span> );</div><div class="line">            <a class="code" href="namespaceRa_1_1Engine_1_1ShaderConfigurationFactory.html#a36842535508a390108fb1205210a5c49">Ra::Engine::ShaderConfigurationFactory::addConfiguration</a>( lpconfig );</div><div class="line">            rt.<a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#aaf860d7c30aef24f7c24016952cd8f00">setConfiguration</a>( lpconfig, <a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#af803212454983777ba8caaa24163e51da9c843288b3e60ed141014569ae035c0e">Ra::Engine::RenderTechnique::LIGHTING_OPAQUE</a> );</div><div class="line"></div><div class="line">            <span class="comment">// Configuration for RenderTechnique::Z_PREPASS</span></div><div class="line">            <a class="code" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> dpconfig(</div><div class="line">                <span class="stringliteral">&quot;DepthAmbiantBlinnPhong&quot;</span>, <span class="stringliteral">&quot;Shaders/Materials/BlinnPhong/BlinnPhong.vert.glsl&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;Shaders/Materials/BlinnPhong/DepthAmbientBlinnPhong.frag.glsl&quot;</span> );</div><div class="line">            <a class="code" href="namespaceRa_1_1Engine_1_1ShaderConfigurationFactory.html#a36842535508a390108fb1205210a5c49">Ra::Engine::ShaderConfigurationFactory::addConfiguration</a>( dpconfig );</div><div class="line">            rt.<a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#aaf860d7c30aef24f7c24016952cd8f00">setConfiguration</a>( dpconfig, <a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#af803212454983777ba8caaa24163e51dae13b847fdf01551fa704a192597e376c">Ra::Engine::RenderTechnique::Z_PREPASS</a> );</div><div class="line"></div><div class="line">            <span class="comment">// Configuration for RenderTechnique::LIGHTING_TRANSPARENT</span></div><div class="line">            <span class="keywordflow">if</span> ( isTransparent )</div><div class="line">            {</div><div class="line">                <a class="code" href="classRa_1_1Engine_1_1ShaderConfiguration.html">Ra::Engine::ShaderConfiguration</a> tpconfig(</div><div class="line">                    <span class="stringliteral">&quot;LitOITBlinnPhong&quot;</span>, <span class="stringliteral">&quot;Shaders/Materials/BlinnPhong/BlinnPhong.vert.glsl&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;Shaders/Materials/BlinnPhong/LitOITBlinnPhong.frag.glsl&quot;</span> );</div><div class="line">                <a class="code" href="namespaceRa_1_1Engine_1_1ShaderConfigurationFactory.html#a36842535508a390108fb1205210a5c49">Ra::Engine::ShaderConfigurationFactory::addConfiguration</a>( tpconfig );</div><div class="line">                rt.<a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#aaf860d7c30aef24f7c24016952cd8f00">setConfiguration</a>( tpconfig, <a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#af803212454983777ba8caaa24163e51da8cb69950239b9f21365388db545a64fd">Ra::Engine::RenderTechnique::LIGHTING_TRANSPARENT</a> );</div><div class="line">            }</div><div class="line">        } );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> BlinnPhongMaterial::unregisterMaterial() {</div><div class="line">    <a class="code" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#ac41449ebd949e8a7b1d93ff2a42acf92">EngineMaterialConverters::removeMaterialConverter</a>( <span class="stringliteral">&quot;BlinnPhong&quot;</span> );</div><div class="line">    <a class="code" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#a6e2ce86d7ae1f3822819477bf5bd7c74">EngineRenderTechniques::removeDefaultTechnique</a>( <span class="stringliteral">&quot;BlinnPhong&quot;</span> );</div><div class="line">}</div></div><!-- fragment --><p>As the <code>BlinnPhongMaterial</code> is directly managed by the Engine, registration of the material is realized at the initialization of the Engine. We then have, in the <code>RadiumEngine</code> class, the following method : </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> RadiumEngine::initialize() {</div><div class="line">    <a class="code" href="Log_8hpp.html#aba7b09d6e8fbe414c23705ad24dde6ff">LOG</a>( <a class="code" href="namespaceRa_1_1Core_1_1Utils.html#af356995a5aa68a868197746fe85f38baa27e920d9d4c9e99133a5c9c3e4251cb4">logINFO</a> ) &lt;&lt; <span class="stringliteral">&quot;*** Radium Engine ***&quot;</span>;</div><div class="line">    ...</div><div class="line">    <span class="comment">// Engine support some built-in materials. Register them here</span></div><div class="line">    BlinnPhongMaterial::registerMaterial();</div><div class="line">}</div></div><!-- fragment --><h3>Asssociate the material with a RenderTechnique inside a RenderObject</h3>
<p>The conversion of a <code>FileData</code> structure, resulting from the loading of a data file to entities and components that are managed by the Engine and Renderers are in charge of the loading system, by default the <code>FancyMesh</code> system.</p>
<p>Thanks to the <code>MaterialData</code> interface, the <code>Material</code> interface, the <code>EngineMaterialConverters</code> factory and the <code>EngineRenderTechniques</code> factory, this task is generic and is the same for every registered materials. So, once a material is developed following the above description, is will be directly usable in the <code>ForwardRenderer</code> thanks to the following <code>FancyMesh</code>method :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FancyMeshComponent::handleMeshLoading( <span class="keyword">const</span> Ra::Asset::GeometryData* data ) {</div><div class="line">    <span class="comment">// convert the GeometryData into a Renderable Mesh</span></div><div class="line">    ...</div><div class="line">    <span class="comment">// Convert the MaterialData into a Material and its associated render technique</span></div><div class="line"></div><div class="line">    <span class="comment">// First, get the concrete MaterialData</span></div><div class="line">    <span class="keyword">const</span> Ra::Asset::MaterialData&amp; loadedMaterial = data-&gt;getMaterial();</div><div class="line">    <span class="comment">// Second, convert the material from asset to Engine</span></div><div class="line">    <span class="keyword">auto</span> converter =</div><div class="line">            <a class="code" href="namespaceRa_1_1Engine_1_1EngineMaterialConverters.html#ad440019d5fdaa657b3a483a705dc3657">Ra::Engine::EngineMaterialConverters::getMaterialConverter</a>( loadedMaterial.getType() );</div><div class="line">    std::shared_ptr&lt;Ra::Engine::Material&gt; radiumMaterial( converter.second( &amp;loadedMaterial ) );</div><div class="line">    <span class="comment">// Third, associate the material to a render technique</span></div><div class="line">    <a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html">Ra::Engine::RenderTechnique</a> rt;</div><div class="line">    rt.<a class="code" href="classRa_1_1Engine_1_1RenderTechnique.html#a9bddcd20723ee582fd81c363b9148cf9">setMaterial</a>( radiumMaterial );</div><div class="line">    <span class="comment">// Fourth, parameterize the technique for rendering this material</span></div><div class="line">    <span class="keyword">auto</span> builder =</div><div class="line">            <a class="code" href="namespaceRa_1_1Engine_1_1EngineRenderTechniques.html#a5e831d5088144082e9bd3828323aa57a">Ra::Engine::EngineRenderTechniques::getDefaultTechnique</a>( loadedMaterial.getType() );</div><div class="line">    builder.second( rt, isTransparent );</div><div class="line"></div><div class="line">    <span class="comment">// Create, parameterize and register the resulting  RenderObject</span></div><div class="line">    <span class="keyword">auto</span> ro = <a class="code" href="classRa_1_1Engine_1_1RenderObject.html#ae9cb914f351555a60d29e8d6afedc06b">Ra::Engine::RenderObject::createRenderObject</a>(</div><div class="line">        roName, <span class="keyword">this</span>, Ra::Engine::RenderObjectType::Fancy, displayMesh, rt );</div><div class="line">    ro-&gt;setTransparent( radiumMaterial-&gt;isTransparent() );</div><div class="line">    setupIO( m_contentName );</div><div class="line">    m_meshIndex = addRenderObject( ro );</div><div class="line">}</div></div><!-- fragment --><h2>Extending the material library from a plugin</h2>
<p>Note that, as we will see in the <em>Extending the material library from a plugin</em> if one want to add a new loadable material in the Engine, this will require to define a loader capable of generating such data.</p>
<p>Given the description above, one can extend the material library from a plugin or from an application. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 23 2019 09:35:42 for Radium Engine by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
